from pathlib import Path

path = Path(''index.html'')
text = path.read_text()
start = text.index(''async function loadData() {'')
end = text.index(''loadData();'', start) + len(''loadData();\r\n'')
lines = [
    "async function loadData() {",
    "  let baseData = null;",
    "  let usedFallback = false;",
    "  const getEmbeddedDetails = () => {",
    "    try {",
    "      if (window.HEIC_DETAILS && typeof window.HEIC_DETAILS === 'object') return window.HEIC_DETAILS;",
    "    } catch(_) {}",
    "    return null;",
    "  };",
    "  try {",
    "    const res = await fetch('details.json', { cache: 'no-store' });",
    "    if (!res.ok) throw new Error('Failed to load details.json: ' + res.status);",
    "    baseData = await res.json();",
    "    try { window.HEIC_DETAILS = baseData; } catch(_) {}",
    "  } catch(fetchErr) {",
    "    const fallback = getEmbeddedDetails();",
    "    if (fallback) {",
    "      baseData = fallback;",
    "      usedFallback = true;",
    "      console.warn('Falling back to embedded details payload', fetchErr);",
    "      const note = document.createElement('div');",
    "      note.style.color = '#f66';",
    "      note.style.padding = '8px';",
    "      note.textContent = 'Using built-in compendium data. For live updates serve the files via a local server.';",
    "      document.body.insertBefore(note, document.body.firstChild);",
    "    } else {",
    "      console.error('Error loading details.json', fetchErr);",
    "      const msg = document.createElement('div');",
    "      msg.style.color = '#f66';",
    "      msg.style.padding = '8px';",
    "      msg.textContent = 'Failed to load details.json. Please serve files via a local server (e.g., python -m http.server) instead of opening via file://';",
    "      document.body.insertBefore(msg, document.body.firstChild);",
    "      return;",
    "    }",
    "  }",
    "  RAW_DATA = baseData || {};",
    "  // Attempt to load optional stats_overrides.json and merge it into RAW_DATA.",
    "  try {",
    "    const resO = await fetch('stats_overrides.json', { cache: 'no-store' });",
    "    if (resO.ok) {",
    "      const overrides = await resO.json();",
    "      for (const [k, statObj] of Object.entries(overrides || {})) {",
    "        if (RAW_DATA[k]) {",
    "          const baseStats = RAW_DATA[k].stats || {};",
    "          RAW_DATA[k].stats = Object.assign({}, baseStats, statObj);",
    "        }",
    "      }",
    "    }",
    "  } catch(oerr) {",
    "    // Ignore missing overrides file; it's optional.",
    "  }",
    "  DATA_ARR = Object.entries(RAW_DATA).map(([key,val]) => { val.key = key; return val; });",
    "  // Build a set of keys that support Gold/Diamond tiers either because:",
    "  // - effect text mentions Gold/Diamond, or",
    "  // - sibling variant slugs *_gold or *_diamond exist.",
    "  window.TIERABLE = new Set();",
    "  const keys = Object.keys(RAW_DATA);",
    "  const hasVariant = (slug) => keys.some(k => /^(items|weapons)\\//.test(k) && (k.endsWith(slug+\"_gold\") || k.endsWith(slug+\"_diamond\")));",
    "  for (const [k, v] of Object.entries(RAW_DATA)){",
    "    if (!v || typeof v !== 'object') continue;",
    "    const eff = (v.effect||'');",
    "    const m = /^(items|weapons)\\/(.+)$/.exec(k);",
    "    const baseSlug = m ? m[2] : '';",
    "    if (/gold|diamond/i.test(eff) || hasVariant(baseSlug)) {",
    "      window.TIERABLE.add(k);",
    "    }",
    "  }",
    "  // Populate edge selects once data is ready",
    "  populateEdges();",
    "  // Build empty item grids for both sides",
    "  initSlots();",
    "  // Render the compendium grid",
    "  renderGrid();",
    "  // Compute initial totals for player and opponent (empty builds)",
    "  updateTotals('P');",
    "  updateTotals('O');",
    "}",
    "loadData();"
]
new_block = '\r\n'.join(lines) + '\r\n'
print(new_block.splitlines()[0:6])
text = text[:start] + new_block + text[end:]
path.write_text(text)
