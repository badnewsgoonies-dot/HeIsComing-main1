?<title>He Is Coming â€” Loadout Builder (v5)</title>
<meta charset="utf-8">
<style>
html,body { margin:0; height:100%; background:#000; color:#f33; font-family: Inter, system-ui, Arial, sans-serif; }
/* Slightly smaller font for a more compact UI */
html { font-size:13px; }
header { padding:10px 16px; border-bottom:2px solid #f33; }
.frame {
  display: grid;
  grid-template-columns: 300px minmax(0, 1fr) 300px;
  gap: 6px;
  height: calc(100vh - 52px);
  padding: 6px;
  overflow: hidden;
}
.panel {
  background:#000;
  border:2px solid #f33;
  border-radius:10px;
  padding:6px;
  display:flex;
  flex-direction:column;
  min-height:0;
  overflow:auto; /* allow column to scroll instead of page */
}
.title { font-size:12px; color:#f33; margin:4px 2px 6px; }
.oils { display:flex; flex-direction:column; gap:6px; }
.oil { display:flex; align-items:center; gap:8px; border:2px solid #f33; border-radius:8px; padding:6px; cursor:pointer; }
.oil img { width:22px; height:22px; image-rendering:pixelated; }
.oil.active { background:#300; }
.weapon-slot { border:2px dashed #f33; border-radius:10px; padding:8px; text-align:center; margin:8px 0; min-height:48px; display:flex; align-items:center; justify-content:center; }
.grid12 {
  display:grid;
  grid-template-columns: repeat(2, 1fr);
  grid-auto-rows: 60px;
  gap:6px;
  flex:1;
}
.slot { border:2px dashed #f33; border-radius:10px; display:flex; align-items:center; justify-content:center; color:#f33; }
.slot.filled { border-style:solid; }
.slot img { width:40px; height:40px; image-rendering:pixelated; }
.weapon-slot img { width:48px; height:48px; image-rendering:pixelated; }
.edge-tile { border:2px solid #f33; border-radius:10px; padding:6px; display:flex; flex-direction:column; gap:6px; margin-bottom:8px; }
.edge-body { display:flex; align-items:center; gap:8px; }
.edge-body img { width:20px; height:20px; image-rendering:pixelated; }
.edge-tile select { flex:1; background:#000; color:#f33; border:1px solid #f33; border-radius:6px; padding:4px 6px; }
.stats { display:flex; flex-direction: column; align-items:flex-start; gap:6px; padding-top:8px; border-top:2px solid #f33; }
.stat {
  display: flex;
  align-items: center;
  gap: 10px;
  background: #2f5d1a;
  border: 2px solid #95d5b2;
  border-radius: 999px;
  padding: 8px 18px;
  font-size: 20px;
  color: #fff;
  font-weight: bold;
  box-shadow: 0 2px 8px rgba(149,213,178,0.25);
  margin-bottom: 6px;
}
.stat img {
  width: 28px;
  height: 28px;
  image-rendering: pixelated;
}
  .center {
    background: #111;
    border: 2px solid #f33;
    border-radius: 12px;
    min-height: 0; /* allow children to shrink for scrolling */
    height: 100%;
    display: flex;
    flex-direction: column;
    max-width: none; /* fill available width to avoid narrow center */
    margin: 0;
    width: 100%;
    box-sizing: border-box;
    overflow: hidden; /* inner grid scrolls */
  }
  .toolbar { display:flex; gap:8px; align-items:center; padding:8px; border-bottom:2px solid #f33; flex-wrap:wrap; }
  input[type='search'], select, button { background:#1b1216; color:#f33; border:1px solid #f33; border-radius:8px; padding:6px 10px; }
  .grid {
    flex: 1 1 auto;
    min-height: 0; /* required for child scroll in flex */
    overflow: auto; /* make the compendium the scrollable area */
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 10px;
    padding: 14px;
    justify-items: stretch;
    align-content: start;
    width: 100%;
    box-sizing: border-box;
  }

  /* Mini card styling for filled slots and weapon */
  .miniCard {
    display:flex; align-items:center; gap:8px;
    border:2px solid #f33; border-radius:12px; padding:6px 8px;
    background:#111; color:#fff; box-shadow: 0 2px 8px rgba(255,51,51,0.15);
  }
  .miniCard img { width:28px; height:28px; image-rendering:pixelated; }
  .slot.filled { border-style:solid; }
  .slot.filled .miniCard .name { font-size:12px; color:#faa; }

  .card {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    border: 2px solid #f33;
    border-radius: 16px;
    padding: 14px;
    background: #111;
    color: #fff;
    font-size: 12px;
    max-width: 420px;
    width: 100%;
    box-sizing: border-box;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(255, 51, 51, 0.2);
  }

  .card:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(255, 51, 51, 0.3);
    border-color: #f55;
    background: #1a1a1a;
  }

  .card[data-cat="Jewelry"] { border-color: #ffd166; box-shadow: 0 4px 12px rgba(255, 209, 102, 0.2); }
  .card[data-cat="Jewelry"]:hover { border-color: #ffe0a3; box-shadow: 0 6px 16px rgba(255, 209, 102, 0.3); }

  .card[data-cat="Tome"] { border-color: #73d2de; box-shadow: 0 4px 12px rgba(115, 210, 222, 0.2); }
  .card[data-cat="Tome"]:hover { border-color: #a1e3eb; box-shadow: 0 6px 16px rgba(115, 210, 222, 0.3); }

  .card[data-cat="Food"] { border-color: #95d5b2; box-shadow: 0 4px 12px rgba(149, 213, 178, 0.2); }
  .card[data-cat="Food"]:hover { border-color: #b7e4cc; box-shadow: 0 6px 16px rgba(149, 213, 178, 0.3); }
  .card[data-cat="Jewelry"]{ border-color:#ffd166; }
  .card[data-cat="Tome"]{ border-color:#73d2de; }
  .card[data-cat="Food"]{ border-color:#95d5b2; }
  /* Keyboard focus ring for cards */
  .card:focus-visible { outline: 2px solid #f55; outline-offset: 2px; }
  /* Clamp effect text to two lines inside cards */
  .card .effect {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  /* Optional: visible focus ring on slots for future keyboard nav */
  .slot:focus-visible { outline: 2px solid #f55; outline-offset: 3px; }
  /* Selected slot highlight */
.slot.active { box-shadow: 0 0 0 3px #f55 inset; background:#120; }
  /* Card quick actions (Add P / Add O) */
  .card__actions { display:none; gap:6px; margin-left:auto; }
  .card:hover .card__actions, .card:focus .card__actions, .card:focus-within .card__actions { display:flex; }
  .card__btn { background:#1b1216; color:#f33; border:1px solid #f33; border-radius:8px; padding:4px 8px; cursor:pointer; font-size:12px; }
  .selIndicator { font-size: 12px; color:#faa; margin:4px 2px; }
.card .iconWrap { position:relative; }
.card .iconWrap img { width:48px; height:48px; image-rendering:pixelated; }
.card .badge { position:absolute; top:-6px; right:-6px; background:#210; border:1px solid #f33; border-radius:6px; padding:2px 4px; font-size:12px; }
.card .nameUnder { text-align:center; font-size:12px; }

/* Set bonus chips */
.setsBox { display:flex; flex-wrap:wrap; gap:6px; padding-top:8px; border-top:2px solid #f33; margin-top:8px; }
.setChip { display:inline-flex; align-items:center; gap:6px; background:#210; border:1px solid #f33; border-radius:12px; padding:4px 8px; font-size:12px; color:#faa; }
.setChip .name { font-weight:700; color:#fff; }
.setChip img { width:18px; height:18px; image-rendering:pixelated; }

/* Floating simulation panel styling */
/* Simulation panel now in center column, below compendium */
#simPanel {
  width:480px;
  margin:24px auto 0 auto;
  background:#000;
  border:2px solid #f33;
  border-radius:16px;
  padding:18px;
  display:flex;
  flex-direction:column;
  gap:12px;
  z-index:10;
  position:static;
}
#simControls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
#simLog {
  flex:1;
  min-height:180px;
  max-height:320px;
  overflow:auto;
  background:#111;
  border:2px solid #f33;
  border-radius:12px;
  padding:14px;
  font-size:16px;
  font-family:monospace;
  color:#f66;
  white-space:pre-wrap;
}
.meta .name { font-weight:700; }
.meta .slug { font-size:12px; color:#f66; }
.meta .effect { font-size:12px; margin-top:6px; color:#faa; }
.meta .stats { display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; }
.pill {
  display: flex;
  align-items: center;
  gap: 8px;
  background: #2f5d1a;
  border: 2px solid #95d5b2;
  border-radius: 999px;
  padding: 8px 18px;
  font-size: 18px;
  color: #fff;
  font-weight: bold;
  box-shadow: 0 2px 8px rgba(149,213,178,0.25);
}
.pill img {
  width: 22px;
  height: 22px;
  image-rendering: pixelated;
}
.drag-over { outline:2px dashed #f33; }

#detailModal { position:fixed; inset:0; background:rgba(0,0,0,0.8); display:none; align-items:center; justify-content:center; z-index:1000; }
#detailBox { background:#111; border:2px solid #f33; border-radius:12px; padding:16px; color:#f66; max-width:400px; }
#detailBox h2 { margin-top:0; }
#detailClose { background:#333; color:#f33; border:1px solid #f33; border-radius:6px; padding:2px 6px; float:right; cursor:pointer; }
#detailStats { display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; }
</style>
</head>
<body>
<header><h1>He Is Coming â€” Loadout Builder (v5)</h1></header>
<div class="frame">
  <!-- LEFT / PLAYER -->
  <section class="panel" id="panelP">
    <div class="title">Oils</div>
    <div class="oils" id="oilsP">
      <div class="oil" data-kind="attack"><img src="assets/attack.png"><span>Attack Oil</span></div>
      <div class="oil" data-kind="armor"><img src="assets/armor.png"><span>Armor Oil</span></div>
      <div class="oil" data-kind="speed"><img src="assets/speed.png"><span>Speed Oil</span></div>
    </div>
    <div class="weapon-slot" id="weaponP">Drop a Weapon</div>
    <div class="edge-tile">
      <div class="edge-body">
        <img id="edgePIcon" src="assets/placeholder.png" alt="">
        <select id="edgeP"><option value="">â€” Select Edge â€”</option></select>
      </div>
      <div id="edgePEffect" class="meta effect"></div>
    </div>
    <div class="selIndicator" id="selPI">Selected: None</div>
    <div class="grid12" id="gridP"></div>
    <div class="stats">
      <div class="stat"><img src="assets/health.png" alt="health"><span id="pH">10</span></div>
      <div class="stat"><img src="assets/attack.png" alt="atk"><span id="pA">0</span></div>
      <div class="stat"><img src="assets/armor.png" alt="arm"><span id="pR">0</span></div>
      <div class="stat"><img src="assets/speed.png" alt="spd"><span id="pS">0</span></div>
    </div>
    <div class="setsBox" id="setsP"></div>
  </section>

  <!-- CENTER COLUMN -->
  <div style="grid-column: 2; display: flex; flex-direction: column; height: 100%; min-height:0;">
    <div class="tabs" style="display:flex; gap:2px; margin-bottom:8px;">
      <button id="tabCompendium" class="tabBtn" style="background:#111;color:#f33;border:2px solid #f33;border-radius:8px 8px 0 0;padding:8px 24px;cursor:pointer;font-size:16px;">Compendium</button>
      <button id="tabSimulation" class="tabBtn" style="background:#111;color:#0f3;border:2px solid #0f3;border-radius:8px 8px 0 0;padding:8px 24px;cursor:pointer;font-size:16px;">Simulation</button>
    </div>
    <section class="center" id="compendiumTab" style="flex:1; display:flex; flex-direction:column; min-height:0;">
      <div class="toolbar">
        <input id="q" type="search" placeholder="Search name/effect/tagâ€¦">
        <select id="bucket">
          <option value="All">All</option><option value="items">Items</option><option value="weapons">Weapons</option><option value="upgrades">Upgrades</option>
        </select>
        <select id="cat">
          <option value="All">All</option>
          <option value="Jewelry">Jewelry</option><option value="Tome">Tome</option><option value="Food">Food</option>
        </select>
        <button id="randBuildBtn" type="button" title="Fill your slots with random items and a random weapon from the compendium" style="background:#f33;color:#000;border:1px solid #f33;border-radius:8px;padding:6px 10px;cursor:pointer;">ðŸŽ² Random Build</button>
        <button id="randEnemyBtn" type="button" title="Randomize the opponent's loadout" style="background:#f33;color:#000;border:1px solid #f33;border-radius:8px;padding:6px 10px;cursor:pointer;">ðŸŽ² Random Enemy</button>
        <button id="showSimBtn" type="button" style="background:#0f3;color:#000;border:1px solid #0f3;border-radius:8px;padding:6px 10px;cursor:pointer;font-size:16px;margin-left:16px;">Show Simulation</button>
        <span id="count" style="margin-left:auto;">Shown: 0</span>
      </div>
      <div id="grid" class="grid" style="flex:1;"></div>
    </section>
    <section class="center" id="simulationTab" style="flex:1; display:none; flex-direction:column; align-items:center; justify-content:center; min-height:0;">
      <div id="simPanel" style="width:640px;max-width:100%;margin:24px auto;background:#000;border:2px solid #0f3;border-radius:16px;padding:24px;display:flex;flex-direction:column;gap:18px;box-shadow:0 0 32px #000;">
        <div id="simControls" style="display:flex;gap:18px;flex-wrap:wrap;align-items:center;">
          <button id="btnSimulate" type="button" title="Run a simulation between the two loadouts" style="background:#0f3;color:#000;border:1px solid #0f3;border-radius:8px;padding:8px 16px;cursor:pointer;font-size:20px;">â–¶ Simulate</button>
          <button id="btnClearLog" type="button" title="Clear the simulation log" style="background:#333;color:#0f3;border:1px solid #0f3;border-radius:8px;padding:8px 16px;cursor:pointer;font-size:20px;">Clear Log</button>
        </div>
        <div id="simLog" style="flex:1;min-height:240px;max-height:60vh;overflow:auto;background:#111;border:2px solid #0f3;border-radius:12px;padding:18px;font-size:18px;font-family:monospace;color:#0f3;"></div>
      </div>
    </section>
  </div>

  <!-- RIGHT / OPPONENT -->
  <section class="panel" id="panelO">
    <div class="title">Oils</div>
    <div class="oils" id="oilsO">
      <div class="oil" data-kind="attack"><img src="assets/attack.png"><span>Attack Oil</span></div>
      <div class="oil" data-kind="armor"><img src="assets/armor.png"><span>Armor Oil</span></div>
      <div class="oil" data-kind="speed"><img src="assets/speed.png"><span>Speed Oil</span></div>
    </div>
    <div class="weapon-slot" id="weaponO">Drop a Weapon</div>
    <div class="edge-tile">
      <div class="edge-body">
        <img id="edgeOIcon" src="assets/placeholder.png" alt="">
        <select id="edgeO"><option value="">â€” Select Edge â€”</option></select>
      </div>
      <div id="edgeOEffect" class="meta effect"></div>
    </div>
    <div class="selIndicator" id="selOI">Selected: None</div>
    <div class="grid12" id="gridO"></div>
    <div class="stats">
      <div class="stat"><img src="assets/health.png" alt="health"><span id="oH">10</span></div>
      <div class="stat"><img src="assets/attack.png" alt="atk"><span id="oA">0</span></div>
      <div class="stat"><img src="assets/armor.png" alt="arm"><span id="oR">0</span></div>
      <div class="stat"><img src="assets/speed.png" alt="spd"><span id="oS">0</span></div>
    </div>
    <div class="setsBox" id="setsO"></div>
  </section>
</div>

<!-- Simulation panel removed from bottom of page -->

<div id="detailModal">
  <div id="detailBox">
    <button id="detailClose">Close</button>
    <h2 id="detailName"></h2>
    <div id="detailEffect"></div>
    <div id="detailStats"></div>
  </div>
</div>

<!-- Note: details are loaded from details.json via fetch.
     For file:// usage (no local server), we also ship a pre-bundled
     details.js that defines window.HEIC_DETAILS as a fallback. -->
<script src="details.js"></script>
<script src="heic_sim.js"></script>
<script src="heic_effects.js"></script>
<script src="heic_sets.js"></script>

<script>
/* Main builder logic using embedded details data */
let RAW_DATA = {};
let DATA_ARR = [];
async function loadData() {
  try {
    // If pre-bundled details are present (e.g., when opened via file://), use them.
    if (window.HEIC_DETAILS && typeof window.HEIC_DETAILS === 'object') {
      RAW_DATA = window.HEIC_DETAILS;
    } else {
      const res = await fetch('details.json', { cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to load details.json: ' + res.status);
      RAW_DATA = await res.json();
      try { window.HEIC_DETAILS = RAW_DATA; } catch(_) {}
    }
    // Attempt to load optional stats_overrides.json and merge it into RAW_DATA.
    try {
      const resO = await fetch('stats_overrides.json', { cache: 'no-store' });
      if (resO.ok) {
        const overrides = await resO.json();
        for (const [k, statObj] of Object.entries(overrides || {})) {
          if (RAW_DATA[k]) {
            const baseStats = RAW_DATA[k].stats || {};
            RAW_DATA[k].stats = Object.assign({}, baseStats, statObj);
          }
        }
      }
    } catch(oerr) {
      // Ignore missing overrides file; it's optional.
    }
    DATA_ARR = Object.entries(RAW_DATA).map(([key,val]) => { val.key = key; return val; });
    // Build a set of keys that support Gold/Diamond tiers either because:
    // - effect text mentions Gold/Diamond, or
    // - sibling variant slugs *_gold or *_diamond exist.
    window.TIERABLE = new Set();
    const keys = Object.keys(RAW_DATA);
    const hasVariant = (slug) => keys.some(k => /^(items|weapons)\//.test(k) && (k.endsWith(slug+"_gold") || k.endsWith(slug+"_diamond")));
    for (const [k, v] of Object.entries(RAW_DATA)){
      if (!v || typeof v !== 'object') continue;
      const eff = (v.effect||'');
      const m = /^(items|weapons)\/(.+)$/.exec(k);
      const baseSlug = m ? m[2] : '';
      if (/gold|diamond/i.test(eff) || hasVariant(baseSlug)) {
        window.TIERABLE.add(k);
      }
    }
    // Populate edge selects once data is ready
    populateEdges();
    // Build empty item grids for both sides
    initSlots();
    // Render the compendium grid
    renderGrid();
    // Compute initial totals for player and opponent (empty builds)
    updateTotals('P');
    updateTotals('O');
  } catch(err) {
    console.error('Error loading details.json', err);
    const msg = document.createElement('div');
    msg.style.color = '#f66';
    msg.style.padding = '8px';
    msg.textContent = 'Failed to load details.json. Please serve files via a local server (e.g., python -m http.server) instead of opening via file://';
    document.body.insertBefore(msg, document.body.firstChild);
  }
}
loadData();
// Icons for stats
const ICONS = { attack:'assets/attack.png', health:'assets/health.png', armor:'assets/armor.png', speed:'assets/speed.png' };

const $ = sel => document.querySelector(sel);
const grid = $('#grid');
const countSpan = $('#count');
const searchIn = $('#q');
const bucketSel = $('#bucket');
const catSel = $('#cat');
const detailModal = $('#detailModal');
const detailName = $('#detailName');
const detailEffect = $('#detailEffect');
const detailStats = $('#detailStats');
$('#detailClose').addEventListener('click', () => detailModal.style.display='none');
detailModal.addEventListener('click', e => { if (e.target === detailModal) detailModal.style.display='none'; });

// Number of item slots available per side.  Displayed as empty dashed boxes until filled.
const SLOT_COUNT = 12;

// Selection target for slot-aware actions
let activeTarget = { side: null, idx: -1 };

// Player and opponent state
const sides = {
  P: { hpBase:10, atkBase:0, armBase:0, spdBase:0, weapon:null, items:new Array(SLOT_COUNT).fill(null), edge:null, oils:new Set() },
  O: { hpBase:10, atkBase:0, armBase:0, spdBase:0, weapon:null, items:new Array(SLOT_COUNT).fill(null), edge:null, oils:new Set() }
};

function updateTotals(sideKey) {
  const side = sides[sideKey];
  let hp = side.hpBase, atk = side.atkBase, arm = side.armBase, spd = side.spdBase;
  const addStats = obj => {
    if (!obj) return;
    const s = obj.stats || {};
    hp += (s.health || 0);
    atk += (s.attack || 0);
    arm += (s.armor  || 0);
    spd += (s.speed  || 0);
  };
  addStats(side.weapon);
  side.items.forEach(addStats);
  if (side.weapon) {
    if (side.oils.has('attack')) atk += 1;
    if (side.oils.has('armor')) arm += 1;
    if (side.oils.has('speed')) spd += 1;
  }
  const prefix = sideKey === 'P' ? 'p' : 'o';
  $('#'+prefix+'H').textContent = hp;
  $('#'+prefix+'A').textContent = atk;
  $('#'+prefix+'R').textContent = arm;
  $('#'+prefix+'S').textContent = spd;

  // Render set bonuses summary
  try {
    const allSlugs = [];
    if (side.weapon) allSlugs.push(`${side.weapon.bucket}/${side.weapon.slug}`);
    for (const it of side.items) if (it) allSlugs.push(`${it.bucket}/${it.slug}`);
    const defs = (window.HeICSets && window.HeICSets.computeActive) ? window.HeICSets.computeActive(allSlugs) : [];
    const box = sideKey === 'P' ? document.getElementById('setsP') : document.getElementById('setsO');
    if (box) {
      box.innerHTML = '';
      if (!defs || !defs.length) {
        const span = document.createElement('span');
        span.textContent = 'No set bonuses';
        span.style.color = '#f88';
        box.appendChild(span);
      } else {
        defs.forEach(d => {
          const chip = document.createElement('span');
          chip.className = 'setChip';
          const iconSlug = d.effectSlug || (`sets/${d.key}`);
          chip.innerHTML = `<img src="${iconSlug}/icon.png" alt="${d.name}"><span class="name">${d.name}</span><span class="desc">— ${d.desc}</span>`;
          box.appendChild(chip);
        });
      }
    }
  } catch(_) {}
}

// Initialise the item slot grids for both player and opponent.  This creates SLOT_COUNT
// placeholder cells with a dashed border.  When items are added later via drag-and-drop
// or the random build function, these placeholders are filled in (the border becomes
// solid and the item name is written in the cell).  Without this, the grids would
// appear empty on page load, which confused some users.
function initSlots() {
  ['P','O'].forEach(sk => {
    const gridEl = sk === 'P' ? $('#gridP') : $('#gridO');
    gridEl.innerHTML = '';
    for (let i = 0; i < SLOT_COUNT; i++) {
      const cell = document.createElement('div');
      cell.className = 'slot';
      cell.dataset.idx = String(i);
      
      cell.addEventListener('click', () => {
        const idx = Number(cell.dataset.idx);
        const side = sides[sk];
        selectSlot(sk, idx);
        if (cell.classList.contains('filled')) {
          side.items[idx] = null;
          cell.classList.remove('filled');
          cell.innerHTML = '';
          updateTotals(sk);
        }
      });
      gridEl.appendChild(cell);
    }
  });
}

// Reset the slots for a single side.  Clears the grid and adds back SLOT_COUNT empty cells.
function resetSlots(sideKey) {
  const gridEl = sideKey === 'P' ? $('#gridP') : $('#gridO');
  gridEl.innerHTML = '';
  for (let i = 0; i < SLOT_COUNT; i++) {
    const cell = document.createElement('div');
    cell.className = 'slot';
    cell.dataset.idx = String(i);
    
    cell.addEventListener('click', () => {
      const idx = Number(cell.dataset.idx);
      const side = sides[sideKey];
      selectSlot(sideKey, idx);
      if (cell.classList.contains('filled')) {
        side.items[idx] = null;
        cell.classList.remove('filled');
        cell.innerHTML = '';
        updateTotals(sideKey);
      }
    });
    gridEl.appendChild(cell);
  }
}

// Highlight selection and track active slot
function selectSlot(sideKey, idx){
  const container = sideKey === 'P' ? $('#gridP') : $('#gridO');
  if (container) {
    container.querySelectorAll('.slot.active').forEach(el => el.classList.remove('active'));
    const el = container.querySelector(`.slot[data-idx="${idx}"]`);
    if (el) { el.classList.add('active'); el.focus(); }
  }
  activeTarget = { side: sideKey, idx };
  updateSelIndicators();
}

// Mini card HTML
function mini(it){
  return `<div class="miniCard"><img src="${it.bucket}/${it.slug}/icon.png" alt="${it.name}"><span class="name">${it.name}</span></div>`;
}

function firstEmptyIndex(side){
  const i = side.items.findIndex(x => !x);
  return i === -1 ? 0 : i;
}

// Quick add helpers (used by keyboard nav and UI hooks)
function quickAdd(sideKey, item, tier){
  if (!item) return;
  const side = sides[sideKey];
  if (item.bucket === 'weapons'){
    side.weapon = item;
    const wSlot = sideKey === 'P' ? $('#weaponP') : $('#weaponO');
    if (wSlot) wSlot.innerHTML = mini(item);
    updateTotals(sideKey);
    return;
  }
  if (item.bucket === 'items' || item.bucket === 'upgrades'){
    const idx = firstEmptyIndex(side);
    const annotated = Object.assign({}, item, { tier: tier || 'base' });
    side.items[idx] = annotated;
    const gridEl = sideKey === 'P' ? $('#gridP') : $('#gridO');
    const el = gridEl?.querySelector(`.slot[data-idx="${idx}"]`);
    if (el){ el.innerHTML = mini(item); el.classList.add('filled'); }
    selectSlot(sideKey, idx);
    updateTotals(sideKey);
  }
}

function quickAddToActive(item){
  if (activeTarget.side){
    quickAdd(activeTarget.side, item);
  } else {
    quickAdd('P', item);
  }
}

// Update selected slot labels
function updateSelIndicators(){
  const pi = document.getElementById('selPI');
  const oi = document.getElementById('selOI');
  if (pi) pi.textContent = (activeTarget.side === 'P' && activeTarget.idx >= 0) ? `Selected: P slot ${activeTarget.idx+1}` : 'Selected: None';
  if (oi) oi.textContent = (activeTarget.side === 'O' && activeTarget.idx >= 0) ? `Selected: O slot ${activeTarget.idx+1}` : 'Selected: None';
}

// Clear the currently active slot
function clearActiveSlot(){
  if (!activeTarget.side || activeTarget.idx < 0) return;
  const sideKey = activeTarget.side;
  const idx = activeTarget.idx;
  const side = sides[sideKey];
  if (!side) return;
  side.items[idx] = null;
  const gridEl = sideKey === 'P' ? $('#gridP') : $('#gridO');
  const cell = gridEl?.querySelector(`.slot[data-idx="${idx}"]`);
  if (cell){ cell.classList.remove('filled'); cell.innerHTML = ''; }
  updateTotals(sideKey);
}

// (Delete/Backspace clear shortcut removed as requested)

// (Keyboard shortcuts removed as requested)

function showDetail(entry) {
  detailName.textContent = entry.name;
  detailEffect.textContent = entry.effect || '';
  detailStats.innerHTML = '';
  ['attack','health','armor','speed'].forEach(st => {
    const val = entry.stats && typeof entry.stats[st] === 'number' ? entry.stats[st] : 0;
    const pill = document.createElement('span'); pill.className='pill';
    const pImg = document.createElement('img'); pImg.src = ICONS[st];
    const pTxt = document.createElement('span'); pTxt.textContent = `${st[0].toUpperCase()+st.slice(1)}: ${val}`;
    pill.append(pImg, pTxt);
    detailStats.appendChild(pill);
  });
  detailModal.style.display = 'flex';
}

function renderGrid() {
  const term = searchIn.value.trim().toLowerCase();
  const bucketVal = bucketSel.value;
  const catVal = catSel.value;
  let shown = 0;
  grid.innerHTML = '';
  DATA_ARR.forEach(entry => {
    if (bucketVal !== 'All' && entry.bucket !== bucketVal) return;
    if (catVal !== 'All') {
      if (!entry.tags || !entry.tags.includes(catVal)) return;
    }
    const hay = `${entry.name} ${entry.effect || ''} ${entry.key}`.toLowerCase();
    if (term && !hay.includes(term)) return;
    shown++;
    const card = document.createElement('div'); card.className='card';
    card.draggable = true; card.dataset.key = entry.key;
    card.dataset.cat = (entry.tags||[]).find(t=>t==='Jewelry'||t==='Tome'||t==='Food') || '';

    // Top row: icon, name/slug, tier selector, quick actions
    const topRow = document.createElement('div'); topRow.style.display='flex'; topRow.style.alignItems='center'; topRow.style.gap='8px';
    // Icon
    const icon = document.createElement('img');
    icon.src = `${entry.bucket}/${entry.slug}/icon.png`;
    icon.alt = entry.name;
    icon.style.width = '48px';
    icon.style.height = '48px';
    icon.style.imageRendering = 'pixelated';
    icon.style.marginRight = '12px';
    // Name and slug
    const nameSlug = document.createElement('div');
    nameSlug.innerHTML = `<div style="font-weight:700;font-size:20px;color:#f33;">${entry.name}</div><div style="font-size:15px;color:#faa;">${entry.key}</div>`;
    topRow.appendChild(icon);
    topRow.appendChild(nameSlug);
    // Tier selector (only shown if item supports tiers)
    const tierSel = document.createElement('select'); tierSel.innerHTML = '<option value="base">Base</option><option value="gold">Gold</option><option value="diamond">Diamond</option>';
    tierSel.style.background = '#1b1216'; tierSel.style.color = '#f33'; tierSel.style.border = '1px solid #f33'; tierSel.style.borderRadius = '8px'; tierSel.style.padding = '2px 6px'; tierSel.style.fontSize = '12px';
    tierSel.addEventListener('click', ev => ev.stopPropagation());
    card.dataset.tier = 'base';
    tierSel.addEventListener('change', () => { card.dataset.tier = tierSel.value; });
    const supportsTier = (window.TIERABLE && window.TIERABLE.has(entry.key));
    if (!supportsTier) tierSel.style.display = 'none';
    // Actions container
    const actions = document.createElement('div'); actions.className = 'card__actions'; actions.style.marginLeft = 'auto';
    const btnP = document.createElement('button'); btnP.className = 'card__btn'; btnP.textContent = 'Add P';
    const btnO = document.createElement('button'); btnO.className = 'card__btn'; btnO.textContent = 'Add O';
    btnP.addEventListener('click', (ev) => { ev.stopPropagation(); quickAdd('P', entry, card.dataset.tier || 'base'); });
    btnO.addEventListener('click', (ev) => { ev.stopPropagation(); quickAdd('O', entry, card.dataset.tier || 'base'); });
    actions.append(tierSel, btnP, btnO);
    topRow.appendChild(actions);

    // Effect text and divider
    const effectDiv = document.createElement('div');
    effectDiv.className = 'effect';
    effectDiv.style.marginTop = '8px';
    effectDiv.style.marginBottom = '8px';
    effectDiv.style.color = '#fff';
    effectDiv.style.fontSize = '12px';
    effectDiv.textContent = entry.effect || '';
    const divider = document.createElement('div');
    divider.style.height = '3px';
    divider.style.background = '#f33';
    divider.style.margin = '8px 0 8px 0';
    divider.style.borderRadius = '2px';

    // Stat pills in two rows
    const statRow1 = document.createElement('div'); statRow1.style.display='flex'; statRow1.style.gap='16px'; statRow1.style.marginBottom='8px';
    const statRow2 = document.createElement('div'); statRow2.style.display='flex'; statRow2.style.gap='16px';
    const statOrder = [
      { key:'attack', label:'Attack', color:'#f33', icon:'assets/attack.png' },
      { key:'armor', label:'Armor', color:'#3af', icon:'assets/armor.png' },
      { key:'health', label:'Health', color:'#95d5b2', icon:'assets/health.png' },
      { key:'speed', label:'Speed', color:'#ffd166', icon:'assets/speed.png' }
    ];
    statOrder.forEach((st, idx) => {
      const val = entry.stats && typeof entry.stats[st.key] === 'number' ? entry.stats[st.key] : 0;
      const pill = document.createElement('div');
      pill.style.display = 'flex';
      pill.style.alignItems = 'center';
      pill.style.gap = '8px';
      pill.style.background = '#210';
      pill.style.border = '2px solid #f33';
      pill.style.borderRadius = '16px';
      pill.style.padding = '8px 18px';
      pill.style.fontSize = '18px';
      pill.style.color = st.color;
      const pImg = document.createElement('img'); pImg.src = st.icon; pImg.style.width='24px'; pImg.style.height='24px'; pImg.style.imageRendering='pixelated';
      const pTxt = document.createElement('span'); pTxt.textContent = `${st.label}: ${val}`;
      pill.appendChild(pImg);
      pill.appendChild(pTxt);
      if (idx < 2) statRow1.appendChild(pill); else statRow2.appendChild(pill);
    });

    // Card layout
    card.style.background = '#000';
    card.style.border = '2px solid #f33';
    card.style.borderRadius = '16px';
    card.style.padding = '14px';
    card.style.margin = '4px';
    card.style.color = '#fff';
    card.style.display = 'flex';
    card.style.flexDirection = 'column';
    card.style.gap = '6px';
    card.style.width = '100%';
    card.style.boxSizing = 'border-box';

    card.appendChild(topRow);
    card.appendChild(effectDiv);
    card.appendChild(divider);
    card.appendChild(statRow1);
    card.appendChild(statRow2);

    card.addEventListener('dragstart', e => {
      e.dataTransfer.setData('text/plain', entry.key);
      try { e.dataTransfer.setData('application/json', JSON.stringify({ key: entry.key, tier: card.dataset.tier || 'base' })); } catch(_){ }
    });
    card.addEventListener('click', () => showDetail(entry));
    grid.appendChild(card);
  });
  countSpan.textContent = `Shown: ${shown}`;
}

// Filter listeners
[searchIn, bucketSel, catSel].forEach(el => el.addEventListener('input', renderGrid));

// Drag and drop helpers
function setupDrop(zoneSel, sideKey, type) {
  const zone = $(zoneSel);
  zone.addEventListener('dragover', e=>{ e.preventDefault(); zone.classList.add('drag-over'); });
  zone.addEventListener('dragleave', ()=> zone.classList.remove('drag-over'));
  zone.addEventListener('drop', e => {
    e.preventDefault(); zone.classList.remove('drag-over');
    const key = e.dataTransfer.getData('text/plain');
    let tier = 'base';
    try { const j = e.dataTransfer.getData('application/json'); if (j) { const obj = JSON.parse(j); if (obj && obj.tier) tier = obj.tier; } } catch(_){}
    const item = RAW_DATA[key];
    if (!item) return;
    const side = sides[sideKey];
  if (type === 'weapon') {
      // Only accept weapons in the weapon slot.  Replace any existing weapon.
      if (item.bucket !== 'weapons') return;
      side.weapon = item;

      zone.innerHTML = `<div class="miniCard"><img src="${item.bucket}/${item.slug}/icon.png" alt="${item.name}"><span class="name">${item.name}</span></div>`;

    } else if (type === 'items') {
      // Only accept items in the item grid.  Do not allow duplicates and do not exceed SLOT_COUNT.
      if (item.bucket !== 'items') return;
      // Determine the intended slot
      let slotEl = e.target.closest('.slot');
      let idx = -1;
      if (slotEl && zone.contains(slotEl)) {
        idx = Number(slotEl.dataset.idx);
      } else {
        idx = side.items.findIndex(x => !x);
        if (idx === -1) idx = 0; // replace first if full
        slotEl = zone.querySelector(`.slot[data-idx="${idx}"]`);
      }
      const annotated = Object.assign({}, item, { tier });
      side.items[idx] = annotated;
      if (slotEl) {
        slotEl.innerHTML = `<div class=\"miniCard\"><img src=\"${item.bucket}/${item.slug}/icon.png\" alt=\"${item.name}\"><span class=\"name\">${item.name}</span></div>`;
        slotEl.classList.add('filled');
        selectSlot(sideKey, idx);
      }
    }
    updateTotals(sideKey);
  });
}
setupDrop('#weaponP','P','weapon');
setupDrop('#gridP','P','items');
setupDrop('#weaponO','O','weapon');
setupDrop('#gridO','O','items');

// Oils toggles
function setupOils(sel, sideKey) {
  $(sel).querySelectorAll('.oil').forEach(el => {
    el.addEventListener('click', () => {
      const kind = el.dataset.kind;
      const side = sides[sideKey];
      if (side.oils.has(kind)) {
        side.oils.delete(kind);
        el.classList.remove('active');
      } else {
        side.oils.add(kind);
        el.classList.add('active');
      }
      updateTotals(sideKey);
    });
  });
}
setupOils('#oilsP','P');
setupOils('#oilsO','O');

// Populate edge selects after data loaded
function populateEdges() {
  const edges = DATA_ARR.filter(e => e.bucket === 'upgrades' && /edge/i.test(e.slug) && !(/_used$/i.test(e.slug) || /_darkened$/i.test(e.slug)));
  const selects = [$('#edgeP'), $('#edgeO')];
  const effects  = [$('#edgePEffect'), $('#edgeOEffect')];
  const icons    = [$('#edgePIcon'), $('#edgeOIcon')];
  selects.forEach((sel, idx) => {
    // Clear existing options except the first placeholder
    while (sel.options.length > 1) sel.remove(1);
    edges.forEach(e => {
      const opt = document.createElement('option');
      opt.value = e.slug;
      opt.textContent = e.name;
      sel.appendChild(opt);
    });
    // When the user changes the selected edge, update the underlying state, effect text
    // and the displayed icon.  If no edge is selected, fall back to the placeholder icon.
    sel.addEventListener('change', () => {
      const pick = edges.find(e => e.slug === sel.value);
      const sideKey = idx === 0 ? 'P' : 'O';
      sides[sideKey].edge = pick || null;
      effects[idx].textContent = pick ? (pick.effect || '') : '';
      const iconEl = icons[idx];
      if (pick) {
        iconEl.src = `${pick.bucket}/${pick.slug}/icon.png`;
      } else {
        iconEl.src = 'assets/placeholder.png';
      }
    });
  });
}
// populateEdges is invoked from loadData() once DATA_ARR is ready

// Randomize a side's loadout
function randomizeSide(targetSide){
  const side = sides[targetSide];
  // Reset state: clear weapon, items, oils and edge selection
  side.weapon = null;
  side.items = new Array(SLOT_COUNT).fill(null);
  side.oils.clear();
  side.edge = null;
  // Reset DOM: weapon slot text, clear oils active class, reset edge select and effect, and rebuild empty item slots
  const wSlot = targetSide === 'P' ? $('#weaponP') : $('#weaponO');
  wSlot.textContent = 'Drop a Weapon';
  const oilsEl = targetSide === 'P' ? $('#oilsP') : $('#oilsO');
  oilsEl.querySelectorAll('.oil.active').forEach(el => el.classList.remove('active'));
  if (targetSide === 'P') {
    $('#edgeP').value = '';
    $('#edgePEffect').textContent = '';
    $('#edgePIcon').src = 'assets/placeholder.png';
  } else {
    $('#edgeO').value = '';
    $('#edgeOEffect').textContent = '';
    $('#edgeOIcon').src = 'assets/placeholder.png';
  }
  resetSlots(targetSide);
  const gridEl = targetSide === 'P' ? $('#gridP') : $('#gridO');
  const weapons = DATA_ARR.filter(e => e.bucket === 'weapons');
  const itemsList = DATA_ARR.filter(e => e.bucket === 'items');
  if (weapons.length) {
    const w = weapons[Math.floor(Math.random()*weapons.length)];
    side.weapon = w;

    wSlot.innerHTML = `<div class="miniCard"><img src="${w.bucket}/${w.slug}/icon.png" alt="${w.name}"><span class="name">${w.name}</span></div>`;

  }
  const copy = itemsList.slice();
  const chosen = [];
  for (let i = 0; i < SLOT_COUNT && copy.length; i++) {
    const idxPick = Math.floor(Math.random() * copy.length);
    const pick = copy.splice(idxPick, 1)[0];
    chosen.push(pick);
  }
  const cells = gridEl.querySelectorAll('.slot');
  chosen.forEach((it, idxItem) => {
    side.items[idxItem] = it;
    const cell = cells[idxItem];
    cell.innerHTML = `<div class=\"miniCard\"><img src=\"${it.bucket}/${it.slug}/icon.png\" alt=\"${it.name}\"><span class=\"name\">${it.name}</span></div>`;
    cell.classList.add('filled');
  });
  updateTotals(targetSide);
  // Select first slot for clarity
  if (chosen.length > 0) selectSlot(targetSide, 0);
}
document.getElementById('randBuildBtn')?.addEventListener('click', () => randomizeSide('P'));
document.getElementById('randEnemyBtn')?.addEventListener('click', () => randomizeSide('O'));

// Collect the current loadout and computed statistics for simulation.  The simulator
// expects an object with a name, a stats object (hp, atk, armor, speed), the
// weapon slug (empty string if none) and a list of item slugs.  This helper reads
// the aggregated numbers from the DOM and extracts the slugs from our side state.
function collectEntityData(sideKey) {
  const prefix = sideKey === 'P' ? 'p' : 'o';
  const hp = parseInt($('#' + prefix + 'H').textContent, 10) || 0;
  const items = (sides[sideKey].items || []).filter(Boolean).map(it => ({ slug: `${it.bucket}/${it.slug}`, tier: it.tier || 'base' }));
  if (sides[sideKey].edge) {
    items.push({ slug: `${sides[sideKey].edge.bucket}/${sides[sideKey].edge.slug}`, tier: 'base' });
  }
  // Inject active set pseudo-items so their hooks participate in the sim
  try {
    const allSlugs = [];
    if (sides[sideKey].weapon) allSlugs.push(`${sides[sideKey].weapon.bucket}/${sides[sideKey].weapon.slug}`);
    for (const it of (sides[sideKey].items||[])) if (it) allSlugs.push(`${it.bucket}/${it.slug}`);
    const setSlugs = (window.HeICSets && window.HeICSets.computeActiveEffectSlugs) ? window.HeICSets.computeActiveEffectSlugs(allSlugs) : [];
    for (const s of (setSlugs||[])) items.push({ slug: s, tier: 'base' });
  } catch(_) {}
  return {
    name: sideKey === 'P' ? 'Player' : 'Opponent',
    hp,
    hpMax: hp,
    atk: parseInt($('#' + prefix + 'A').textContent, 10) || 0,
    armor: parseInt($('#' + prefix + 'R').textContent, 10) || 0,
    speed: parseInt($('#' + prefix + 'S').textContent, 10) || 0,
    weaponSlug: sides[sideKey].weapon ? `${sides[sideKey].weapon.bucket}/${sides[sideKey].weapon.slug}` : null,
    items
  };
}

// -----------------------------------------------------------------------------
// Simulation UI wiring
//
// The simulation panel is a floating box (#simPanel) anchored at the bottom
// right of the viewport. It contains buttons to run a battle, clear the log
// and adjust the number of turns. When the Simulate button is clicked we
// collect the current loadouts, run the simulation via HeICSim and print the
// result and log lines into #simLog. Clear Log simply wipes the log container.

function uiLogClear() {
  const log = document.getElementById('simLog');
  if (log) log.innerHTML = '';
}

function uiLog(lines) {
  const log = document.getElementById('simLog');
  if (!log) return;
  const renderLine = (line) => {
    if (line == null) return;
    const div = document.createElement('div');
    div.className = 'logLine';
    const m = String(line).match(/^::icon:([^:]+)::\s*(.*)$/);
    if (m) {
      const slug = m[1];
      const text = m[2];
      const img = document.createElement('img');
      img.src = slug + '/icon.png';
      img.alt = '';
      img.style.width = '18px';
      img.style.height = '18px';
      img.style.imageRendering = 'pixelated';
      img.style.marginRight = '8px';
      img.style.verticalAlign = 'text-bottom';
      div.appendChild(img);
      div.appendChild(document.createTextNode(text));
    } else {
      div.textContent = String(line);
    }
    log.appendChild(div);
  };
  if (Array.isArray(lines)) { for (const l of lines) renderLine(l); }
  else { renderLine(lines); }
  log.scrollTop = log.scrollHeight;
}

const simBtn = document.getElementById('btnSimulate');
const showSimBtn = document.getElementById('showSimBtn');
// Import tab removed; set to null to avoid undefined references
const tabImport = null;
if (simBtn) {
  simBtn.addEventListener('click', () => {
    updateTotals('P');
    updateTotals('O');
    const left = collectEntityData('P');
    const right = collectEntityData('O');
    uiLogClear();
    if (typeof HeICSim === 'undefined' || !HeICSim.simulate) {
      uiLog('Simulation engine failed to load.');
      return;
    }
  try {
      const res = HeICSim.simulate(left, right);
      uiLog(`Result: ${res.result}`);
      uiLog(`Rounds: ${res.rounds}`);
      if (res.summary) {
        const fmt = (s) => {
          const gained = s.statusesGained && Object.keys(s.statusesGained).length
            ? Object.entries(s.statusesGained).map(([k,v])=>`${k}:${v}`).join(', ')
            : 'none';
          const inflicted = s.statusesInflicted && Object.keys(s.statusesInflicted).length
            ? Object.entries(s.statusesInflicted).map(([k,v])=>`${k}:${v}`).join(', ')
            : 'none';
          return [
            `${s.name} Summary`,
            `  Damage to HP: ${s.hpDamageDealt}`,
            `  Armor destroyed: ${s.armorDestroyedDealt}`,
            `  Bomb HP: ${s.bombHpDealt}`,
            `  Strikes: ${s.strikesLanded}/${s.strikesAttempted}`,
            `  Statuses gained: ${gained}`,
            `  Statuses inflicted: ${inflicted}`
          ].join('\n');
        };
        uiLog('--- Summary ---');
        uiLog(fmt(res.summary.left));
        uiLog('');
        uiLog(fmt(res.summary.right));
        uiLog('----------------');
      }
      if (res.log && res.log.length) uiLog(res.log);
    } catch (ex) {
      console.error(ex);
      uiLog('Error running simulation.');
    }
  });
}
const clearBtn = document.getElementById('btnClearLog');
if (clearBtn) {
  clearBtn.addEventListener('click', () => uiLogClear());
}

// Normalize any garbled labels from past encoding issues
(function normalizeLabels(){
  try {
    const ep = document.getElementById('edgeP');
    if (ep && ep.options && ep.options.length) ep.options[0].textContent = '- Select Edge -';
    const eo = document.getElementById('edgeO');
    if (eo && eo.options && eo.options.length) eo.options[0].textContent = '- Select Edge -';
    const rb = document.getElementById('randBuildBtn'); if (rb) rb.textContent = 'Random Build';
    const re = document.getElementById('randEnemyBtn'); if (re) re.textContent = 'Random Enemy';
    const bs = document.getElementById('btnSimulate'); if (bs) bs.textContent = 'Simulate';
  } catch (_) {}
})();

// Import-from-screenshot (alpha) removed
/*
(function setupImport(){
  const drop = document.getElementById('importDrop');
  const canvas = document.getElementById('importCanvas');
  const ctx = canvas ? canvas.getContext('2d') : null;
  const srcCanvas = document.createElement('canvas');
  const srcCtx = srcCanvas.getContext('2d');
  const logEl = document.getElementById('importLog');
  const fileBtn = document.getElementById('btnLoadImage');
  const fileInput = document.getElementById('imageFile');
  const btnScan = document.getElementById('btnScan');
  const btnApplyBoth = document.getElementById('btnApplyBoth');
  const roiTarget = document.getElementById('roiTarget');
  const roiRows = document.getElementById('roiRows');
  const roiCols = document.getElementById('roiCols');
  const confMinInput = document.getElementById('confMin');
  const chkPreview = document.getElementById('chkPreview');
  const chkOcrEdge = document.getElementById('chkOcrEdge');
  const warnEl = document.getElementById('importWarnings');
  if (!drop || !canvas || !ctx) return;

  const ROIS = { 'left-items': null, 'left-weapon': null, 'left-oils': null, 'left-edge': null, 'right-items': null, 'right-weapon': null, 'right-oils': null, 'right-edge': null };
  let clickStart = null;
  let img = new Image();
  let iconLib = null;
  let oilsLib = null; // attack/armor/speed icons
  let lastHints = [];
  let dragging = null; // {target, kind:'nw'|'ne'|'sw'|'se', ox, oy}
  let warnings = [];
  let presetSide = null; // 'P' | 'O' when preset mode active

  function log(msg){ if (logEl) logEl.textContent += (msg+'\n'); }
  function clearLog(){ if (logEl) logEl.textContent=''; }
  function render(){
    if (!img || !img.width) return;
    const W = canvas.clientWidth|0; const ratio = img.height/img.width; canvas.width = W; canvas.height = Math.max(1, Math.floor(W*ratio));
    ctx.imageSmoothingEnabled = false; ctx.drawImage(srcCanvas && srcCanvas.width ? srcCanvas : img, 0, 0, canvas.width, canvas.height);
    const drawRect = (r, color, withGrid=false, rows=0, cols=0) => {
      if(!r) return; ctx.strokeStyle=color; ctx.lineWidth=2; ctx.strokeRect(r.x, r.y, r.w, r.h);
      if (withGrid && rows>0 && cols>0) {
        ctx.save(); ctx.strokeStyle = color; ctx.globalAlpha = 0.4; ctx.lineWidth = 1;
        const cw = r.w/cols, ch = r.h/rows;
        for (let i=1;i<cols;i++){ ctx.beginPath(); ctx.moveTo(r.x+i*cw, r.y); ctx.lineTo(r.x+i*cw, r.y+r.h); ctx.stroke(); }
        for (let j=1;j<rows;j++){ ctx.beginPath(); ctx.moveTo(r.x, r.y+j*ch); ctx.lineTo(r.x+r.w, r.y+j*ch); ctx.stroke(); }
        ctx.restore();
      }
      // draw handles if this is the active target
      if (roiTarget.value && ROIS[roiTarget.value] === r) {
        const hs = 6; const pts = [[r.x,r.y],[r.x+r.w,r.y],[r.x,r.y+r.h],[r.x+r.w,r.y+r.h]];
        ctx.fillStyle = color; for (const [px,py] of pts){ ctx.fillRect(px-hs/2, py-hs/2, hs, hs); }
      }
    };
    drawRect(ROIS['left-items'], '#0f0', roiTarget.value==='left-items', ROIS['left-items']?.rows||0, ROIS['left-items']?.cols||0);
    drawRect(ROIS['left-weapon'], '#0f0');
    drawRect(ROIS['left-oils'], '#0f0', roiTarget.value==='left-oils', ROIS['left-oils']?.rows||0, ROIS['left-oils']?.cols||0);
    drawRect(ROIS['left-edge'], '#0f0');
    drawRect(ROIS['right-items'], '#f00', roiTarget.value==='right-items', ROIS['right-items']?.rows||0, ROIS['right-items']?.cols||0);
    drawRect(ROIS['right-weapon'], '#f00');
    drawRect(ROIS['right-oils'], '#f00', roiTarget.value==='right-oils', ROIS['right-oils']?.rows||0, ROIS['right-oils']?.cols||0);
    drawRect(ROIS['right-edge'], '#f00');
    // overlay hints
    ctx.save();
    ctx.font = '12px monospace';
    for (const h of lastHints){
      ctx.strokeStyle = h.color || '#fff'; ctx.lineWidth=1; ctx.globalAlpha=0.85; ctx.strokeRect(h.x, h.y, h.w, h.h);
      const label = `${h.name||h.slug} (${h.conf||0}%)`;
      const pad=2; const tw = ctx.measureText(label).width + 2*pad; const th = 14 + 2*pad;
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(h.x, Math.max(0,h.y- (th+1)), tw, th);
      ctx.fillStyle = h.color || '#fff'; ctx.fillText(label, h.x+pad, Math.max(12, h.y-4));
    }
    ctx.restore();
  }
  async function loadImageFile(f){ return new Promise((resolve,reject)=>{ const fr=new FileReader(); fr.onload=()=>{ img=new Image(); img.onload=()=>{ try{ srcCanvas.width = img.naturalWidth || img.width; srcCanvas.height = img.naturalHeight || img.height; srcCtx.imageSmoothingEnabled = false; srcCtx.drawImage(img, 0, 0); } catch(_){ } render(); resolve(); }; img.src=fr.result; }; fr.onerror=reject; fr.readAsDataURL(f); }); }
  drop.addEventListener('dragover', e => { e.preventDefault(); drop.style.background='#112'; });
  drop.addEventListener('dragleave', e => { drop.style.background=''; });
  drop.addEventListener('drop', async e => { e.preventDefault(); drop.style.background=''; const f=e.dataTransfer.files&&e.dataTransfer.files[0]; if(f){ clearLog(); await loadImageFile(f); log('Image loaded. Drag to draw rectangles.'); } });
  document.addEventListener('paste', async e => { const it=(e.clipboardData||{}).items||[]; for(const i of it){ if(i.type && i.type.indexOf('image')===0){ const f=i.getAsFile(); clearLog(); await loadImageFile(f); log('Image pasted.'); break; } } });
  if (fileBtn && fileInput) { fileBtn.addEventListener('click', ()=>fileInput.click()); fileInput.addEventListener('change', async ()=>{ const f=fileInput.files[0]; if(f){ clearLog(); await loadImageFile(f); log('Image loaded.'); } }); }
  // Simple calibrator: drag handles at corners, or drag to create a new ROI
  canvas.addEventListener('mousedown', e => {
    const rect=canvas.getBoundingClientRect(); const x=Math.round(e.clientX-rect.left), y=Math.round(e.clientY-rect.top);
    // Preset mode: draw one rectangle for panel bounds
    if (presetSide){
      dragging = { target: '_preset_', kind: 'new', ox:x, oy:y, start: { x:x, y:y, w:1, h:1 } };
      ROIS._presetPreview = { x:x, y:y, w:1, h:1 };
      render();
      return;
    }
    if (QUICK.active){
      dragging = { target: '_quick_', kind:'new', ox:x, oy:y, start:{ x:x, y:y, w:1, h:1 } };
      ROIS._presetPreview = { x:x, y:y, w:1, h:1 };
      render();
      return;
    }
    const t=roiTarget.value; const r=ROIS[t]; const hs=8;
    if (r) {
      const corners=[{k:'nw',x:r.x,y:r.y},{k:'ne',x:r.x+r.w,y:r.y},{k:'sw',x:r.x,y:r.y+r.h},{k:'se',x:r.x+r.w,y:r.y+r.h}];
      for(const c of corners){ if (Math.abs(x-c.x)<=hs && Math.abs(y-c.y)<=hs){ dragging={target:t, kind:c.k, ox:x, oy:y, start: {...r} }; return; } }
    }
    // Not on a handle (or ROI not defined): begin creating a fresh ROI
    dragging={ target:t, kind:'new', ox:x, oy:y, start:{ x:x, y:y, w:1, h:1 } };
    ROIS[t] = { x:x, y:y, w:1, h:1, rows: parseInt(roiRows.value,10)||12, cols: parseInt(roiCols.value,10)||1 };
    render();
  });
  canvas.addEventListener('mousemove', e => {
    if (!dragging) return; const rect=canvas.getBoundingClientRect(); const x=Math.round(e.clientX-rect.left), y=Math.round(e.clientY-rect.top);
    const t=dragging.target; const r={...dragging.start};
    if (t==='_preset_'){
      r.w = x - r.x; r.h = y - r.y; r.w=Math.max(4,r.w); r.h=Math.max(4,r.h); ROIS._presetPreview = r; render(); return;
    }
    if (t==='_quick_'){
      r.w = x - r.x; r.h = y - r.y; r.w=Math.max(4,r.w); r.h=Math.max(4,r.h); ROIS._presetPreview = r; render(); return;
    }
    if (dragging.kind==='nw'){ r.w += r.x - x; r.h += r.y - y; r.x=x; r.y=y; }
    if (dragging.kind==='ne'){ r.w = x - r.x; r.h += r.y - y; r.y=y; }
    if (dragging.kind==='sw'){ r.w += r.x - x; r.x=x; r.h = y - r.y; }
    if (dragging.kind==='se' || dragging.kind==='new'){ r.w = x - r.x; r.h = y - r.y; }
    r.w=Math.max(4,r.w); r.h=Math.max(4,r.h); ROIS[t]=Object.assign(r,{ rows:ROIS[t].rows, cols:ROIS[t].cols }); render();
  });
  document.addEventListener('mouseup', ()=> {
    if (dragging && dragging.target === '_preset_' && ROIS._presetPreview) {
      const r = ROIS._presetPreview; delete ROIS._presetPreview; dragging=null; if (presetSide) { applyPanelPreset(presetSide, r); presetSide=null; const ph=document.getElementById('presetHint'); if(ph) ph.textContent=''; return; } }
    if (dragging && dragging.target === '_wiz_' && ROIS._presetPreview) {
      const r = ROIS._presetPreview; delete ROIS._presetPreview; dragging=null; if (WIZ && WIZ.active) { onWizardRect(r); return; } }
    if (dragging && dragging.target === '_quick_' && ROIS._presetPreview) {
      const r = ROIS._presetPreview; delete ROIS._presetPreview; dragging=null; if (QUICK && QUICK.active) { onQuickWeaponRect(r); return; } }
    dragging=null;
  });
  function toGray(data){ const out=new Float32Array(data.length/4); for(let i=0,j=0;i<data.length;i+=4,j++){ out[j]=(0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]); } return out; }
  function hashFromCanvas(csrc){ const N=16; const c2=document.createElement('canvas'); c2.width=N; c2.height=N; const cx2=c2.getContext('2d'); cx2.imageSmoothingEnabled=true; cx2.drawImage(csrc,0,0,N,N); const d=cx2.getImageData(0,0,N,N).data; const g=toGray(d); let mean=0; for(let i=0;i<g.length;i++) mean+=g[i]; mean/=g.length; let sd=0; for(let i=0;i<g.length;i++){ const v=g[i]-mean; sd+=v*v; } sd=Math.sqrt(sd/g.length)||1; for(let i=0;i<g.length;i++) g[i]=(g[i]-mean)/sd; return g; }
  function loadCache(){ try { const meta=JSON.parse(localStorage.getItem('HEIC_FP_META')||'null'); const data=JSON.parse(localStorage.getItem('HEIC_FPCACHE_V1')||'null'); if(!meta||!data) return null; const expect=Object.keys(RAW_DATA||{}).filter(k=>/(^items\/|^weapons\/|^upgrades\/)/.test(k)).length; if (meta.len!==expect) return null; return data; } catch(_){ return null; } }
  function saveCache(list){ try { const len=Object.keys(RAW_DATA||{}).filter(k=>/(^items\/|^weapons\/|^upgrades\/)/.test(k)).length; localStorage.setItem('HEIC_FP_META', JSON.stringify({ v:1, len })); localStorage.setItem('HEIC_FPCACHE_V1', JSON.stringify(list)); } catch(_){ /* ignore */ } }
  async function buildIconLib(){ if(iconLib) return iconLib; const cached=loadCache(); if (cached) { iconLib=cached; log(`Icon library loaded from cache (${iconLib.length}).`); return iconLib; } const list=[]; for(const [k,v] of Object.entries(RAW_DATA||{})){ if(!/(^items\/|^weapons\/|^upgrades\/)/.test(k)) continue; const path=`${v.bucket}/${v.slug}/icon.png`; const im=new Image(); await new Promise(res=>{ im.onload=res; im.onerror=res; im.src=path; }); if (!im.width) continue; const tmp=document.createElement('canvas'); tmp.width=im.width||32; tmp.height=im.height||32; const tx=tmp.getContext('2d'); tx.imageSmoothingEnabled=false; tx.drawImage(im,0,0,tmp.width,tmp.height); const fp=hashFromCanvas(tmp); list.push({ slug:k, fp, path }); } iconLib=list; saveCache(list); log(`Icon library ready (${list.length}).`); return iconLib; }
  async function buildOilsLib(){ if (oilsLib) return oilsLib; const entries=[{slug:'oil-attack',path:'assets/attack.png',kind:'attack'},{slug:'oil-armor',path:'assets/armor.png',kind:'armor'},{slug:'oil-speed',path:'assets/speed.png',kind:'speed'}]; const out=[]; for(const e of entries){ const im=new Image(); await new Promise(res=>{ im.onload=res; im.onerror=res; im.src=e.path; }); const tmp=document.createElement('canvas'); tmp.width=im.width||22; tmp.height=im.height||22; const tx=tmp.getContext('2d'); tx.imageSmoothingEnabled=false; tx.drawImage(im,0,0,tmp.width,tmp.height); const fp=hashFromCanvas(tmp); out.push({ slug:e.slug, fp, path:e.path, kind:e.kind }); } oilsLib=out; return out; }
  function viewToSrcRect(x,y,w,h){ if (!srcCanvas.width || !canvas.width) return {sx:0,sy:0,sw:1,sh:1}; const sx = Math.max(0, Math.round(x * srcCanvas.width / canvas.width)); const sy = Math.max(0, Math.round(y * srcCanvas.height / canvas.height)); const sw = Math.max(1, Math.round(w * srcCanvas.width / canvas.width)); const sh = Math.max(1, Math.round(h * srcCanvas.height / canvas.height)); return {sx,sy,sw,sh}; }
  function cropHash(x,y,w,h){ const r=viewToSrcRect(x,y,w,h); const tmp=document.createElement('canvas'); tmp.width=Math.max(1,r.sw); tmp.height=Math.max(1,r.sh); const tx=tmp.getContext('2d'); tx.imageSmoothingEnabled=true; tx.drawImage(srcCanvas,r.sx,r.sy,r.sw,r.sh,0,0,tmp.width,tmp.height); return hashFromCanvas(tmp); }
  function dist(a,b){ let s=0; for(let i=0;i<64;i++){ const d=a[i]-b[i]; s+=d*d; } return s; }
  function toConf(d){ const alpha=0.08; return Math.max(1, Math.min(99, Math.round(100*Math.exp(-alpha*d)))) }
  async function scanAndApply(){ await buildIconLib(); await buildOilsLib(); lastHints.length=0; warnings.length=0; const picks={ left:{items:[],weapon:null,oils:new Set(),edge:null}, right:{items:[],weapon:null,oils:new Set(),edge:null} }; const addHint=(x,y,w,h,slug,conf,color)=>{ const rec={x,y,w,h,slug,conf,color,name:(RAW_DATA[slug]?.name)||slug}; lastHints.push(rec); const min = parseInt(confMinInput?.value||'60',10)||60; if (conf < min) { warnings.push(`${slug} @ ${Math.round(conf)}% (ROI ${x},${y},${w}x${h})`); } };
    const processGrid=(roi,sideKey,isItems=true)=>{ if(!roi) return; const {x,y,w,h,rows,cols}=roi; const cw=Math.floor(w/cols), ch=Math.floor(h/rows); const padPctEl = document.getElementById('padPct'); const pct = Math.max(0, Math.min(40, parseInt(padPctEl?.value||'18',10)||18))/100; const shrink = (cx,cy,cw,ch) => { const pad=Math.floor(Math.min(cw,ch)*pct); return [cx+pad, cy+pad, Math.max(2,cw-2*pad), Math.max(2,ch-2*pad)]; }; for(let r=0;r<rows;r++){ for(let c=0;c<cols;c++){ const cx=x+c*cw, cy=y+r*ch; const [sx,sy,sw,sh]=shrink(cx,cy,cw,ch); const fp=cropHash(sx,sy,sw,sh); let best=null, bd=1e9; const lib=isItems?iconLib:oilsLib; for(const it of lib){ const d=dist(fp,it.fp); if(d<bd){ bd=d; best=it; } } const conf = toConf(bd); if(best){ if (isItems) { if (conf >= (parseInt(confMinInput?.value||'60',10)||60)) (sideKey==='P'?picks.left.items:picks.right.items).push(best.slug); addHint(sx,sy,sw,sh,best.slug,conf, sideKey==='P'?'#0f0':'#f00'); } else { const kind=best.kind; (sideKey==='P'?picks.left.oils:picks.right.oils).add(kind); addHint(sx,sy,sw,sh,kind, conf, sideKey==='P'?'#0f0':'#f00'); } } } } };
    const processRect=(roi,sideKey,onlyWeapons=false,onlyUpgrades=false)=>{ if(!roi) return; const padPctEl=document.getElementById('padPct'); const pct = Math.max(0, Math.min(40, parseInt(padPctEl?.value||'18',10)||18))/100; const pad=Math.floor(Math.min(roi.w,roi.h)*pct); const sx=roi.x+pad, sy=roi.y+pad, sw=Math.max(2,roi.w-2*pad), sh=Math.max(2,roi.h-2*pad); const fp=cropHash(sx,sy,sw,sh); let best=null, bd=1e9; for(const it of iconLib){ if (onlyWeapons && !/^weapons\//.test(it.slug)) continue; if (onlyUpgrades && !/^upgrades\//.test(it.slug)) continue; const d=dist(fp,it.fp); if(d<bd){ bd=d; best=it; } } const conf=toConf(bd); if(best){ if(onlyWeapons){ if(conf >= (parseInt(confMinInput?.value||'60',10)||60)) { if(sideKey==='P') picks.left.weapon=best.slug; else picks.right.weapon=best.slug; } } if(onlyUpgrades){ if(conf >= (parseInt(confMinInput?.value||'60',10)||60)) { if(sideKey==='P') picks.left.edge=best.slug; else picks.right.edge=best.slug; } } addHint(sx,sy,sw,sh,best.slug,conf, sideKey==='P'?'#0f0':'#f00'); } };

    // Optional OCR for edge slugs
    async function ensureTesseract(){ if (window.Tesseract) return; await new Promise((res)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/tesseract.js@v5.0.2/dist/tesseract.min.js'; s.onload=res; s.onerror=res; document.body.appendChild(s); }); }
    function lev(a,b){ a=a.toLowerCase(); b=b.toLowerCase(); const m=a.length,n=b.length; const dp=Array.from({length:m+1},()=>Array(n+1).fill(0)); for(let i=0;i<=m;i++) dp[i][0]=i; for(let j=0;j<=n;j++) dp[0][j]=j; for(let i=1;i<=m;i++){ for(let j=1;j<=n;j++){ dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+(a[i-1]===b[j-1]?0:1)); } } return dp[m][n]; }
    function bestByText(text){ if(!text) return null; const names=[]; for(const [k,v] of Object.entries(RAW_DATA||{})){ if(/^upgrades\//.test(k)) names.push({slug:k, name: (v.name||k)}); } const t=text.trim().toLowerCase(); let best=null, bs=-1; for(const e of names){ const s=1 - (lev(t, e.name.toLowerCase()) / Math.max(t.length, e.name.length)); if (s>bs){ bs=s; best=e; } } return best ? { slug:best.slug, sim:best ? Math.round(best && (1 - (lev(t, best.name.toLowerCase()) / Math.max(t.length,best.name.length))) * 100) : 0 } : null; }
    async function tryOcrEdge(roi, sideKey){ if (!roi || !chkOcrEdge?.checked) return null; try { await ensureTesseract(); if (!window.Tesseract) return null; const tmp=document.createElement('canvas'); tmp.width=Math.max(1,roi.w); tmp.height=Math.max(1,roi.h); const tx=tmp.getContext('2d'); tx.drawImage(canvas, roi.x, roi.y, roi.w, roi.h, 0,0,tmp.width,tmp.height); const dataUrl=tmp.toDataURL(); const res= await window.Tesseract.recognize(dataUrl,'eng'); const text=(res && res.data && res.data.text || '').replace(/\s+/g,' ').trim(); if (!text) return null; const best=bestByText(text); if (best && best.slug){ addHint(roi.x,roi.y,roi.w,roi.h,best.slug,best.sim, sideKey==='P'?'#0f0':'#f00'); return best.slug; } } catch(_){} return null; }
    // items & weapons
    processGrid(ROIS['left-items'],'P',true); processRect(ROIS['left-weapon'],'P',true,false);
    processGrid(ROIS['right-items'],'O',true); processRect(ROIS['right-weapon'],'O',true,false);
    // oils
    processGrid(ROIS['left-oils'],'P',false); processGrid(ROIS['right-oils'],'O',false);
    // edges (if icons exist)
    processRect(ROIS['left-edge'],'P',false,true); processRect(ROIS['right-edge'],'O',false,true);
    // OCR fallback for edges
    const lOcr = await tryOcrEdge(ROIS['left-edge'],'P'); if (lOcr) picks.left.edge = lOcr;
    const rOcr = await tryOcrEdge(ROIS['right-edge'],'O'); if (rOcr) picks.right.edge = rOcr;
    render();
    function applySide(key,pred){ const side=key==='P'?sides.P:sides.O; const wSlot=key==='P'?document.getElementById('weaponP'):document.getElementById('weaponO'); if(pred.weapon && RAW_DATA[pred.weapon]){ side.weapon=RAW_DATA[pred.weapon]; if(wSlot) wSlot.innerHTML=`<div class="miniCard"><img src="${side.weapon.bucket}/${side.weapon.slug}/icon.png"><span class="name">${side.weapon.name||side.weapon.slug}</span></div>`; }
      const gridEl=key==='P'?document.getElementById('gridP'):document.getElementById('gridO'); const cells=gridEl?gridEl.querySelectorAll('.slot'):[]; const list=(pred.items||[]).filter(s=>/^items\//.test(s)).slice(0,SLOT_COUNT); for(let i=0;i<SLOT_COUNT;i++){ const slug=list[i]; const cell=cells[i]; if(slug && RAW_DATA[slug]){ const it=RAW_DATA[slug]; side.items[i]=it; if(cell){ cell.classList.add('filled'); cell.innerHTML=`<div class=\"miniCard\"><img src=\"${it.bucket}/${it.slug}/icon.png\"><span class=\"name\">${it.name||it.slug}</span></div>`; } } else { side.items[i]=null; if(cell){ cell.classList.remove('filled'); cell.innerHTML=''; } } } updateTotals(key); }
    function applyOils(key,set){ const box = key==='P'?document.getElementById('oilsP'):document.getElementById('oilsO'); const kinds=['attack','armor','speed']; if (box){ kinds.forEach(k=>{ const el = box.querySelector(`.oil[data-kind="${k}"]`); if (el){ if (set.has(k)) el.classList.add('active'); else el.classList.remove('active'); } }); } const side = key==='P'?sides.P:sides.O; side.oils = new Set(set); updateTotals(key); }
    function applyEdge(key, slug){ if (!slug || !RAW_DATA[slug]) return; const side = key==='P'?sides.P:sides.O; side.edge = RAW_DATA[slug]; const sel = key==='P'?document.getElementById('edgeP'):document.getElementById('edgeO'); const eff = key==='P'?document.getElementById('edgePEffect'):document.getElementById('edgeOEffect'); const ic = key==='P'?document.getElementById('edgePIcon'):document.getElementById('edgeOIcon'); if (sel){ sel.value = side.edge.slug; } if (eff){ eff.textContent = side.edge.effect || ''; } if (ic){ ic.src = `${side.edge.bucket}/${side.edge.slug}/icon.png`; } updateTotals(key); }
    // Fill warnings list
    if (warnEl){ warnEl.textContent = warnings.length ? ('Low-confidence matches:\n- ' + warnings.join('\n- ')) : 'No low-confidence matches.'; }
    // Preview-only toggle
    const preview = !!(chkPreview && chkPreview.checked);
    if (!preview){
      applySide('P',{weapon:picks.left.weapon,items:picks.left.items}); applySide('O',{weapon:picks.right.weapon,items:picks.right.items});
      applyOils('P', picks.left.oils||new Set()); applyOils('O', picks.right.oils||new Set());
      if (picks.left.edge) applyEdge('P', picks.left.edge);
      if (picks.right.edge) applyEdge('O', picks.right.edge);
      log('Applied best matches.');
    } else {
      log('Preview only: not applied.');
    }
  }
  if(btnScan) btnScan.addEventListener('click', scanAndApply); if(btnApplyBoth) btnApplyBoth.addEventListener('click', scanAndApply);
  // Preset buttons
  const presetHint = document.getElementById('presetHint');
  const btnPresetLeft = document.getElementById('btnPresetLeft');
  const btnPresetRight = document.getElementById('btnPresetRight');
  const btnQuickLeft = document.getElementById('btnQuickLeft');
  const btnQuickRight = document.getElementById('btnQuickRight');
  const quickHint = document.getElementById('quickHint');
  const QUICK = { active:false, side:null };
  function applyPanelPreset(sideKey, panel){
    // Normalize rect (ensure positive w/h)
    let x=panel.x, y=panel.y, w=panel.w, h=panel.h; if (w<0){ x+=w; w=-w; } if (h<0){ y+=h; h=-h; }
    const mX = Math.round(w * 0.10), mTop = Math.round(h * 0.06), mBot = Math.round(h * 0.06);
    const tile = Math.round(h * 0.06 * 1.6); // approx tile based on height
    // Weapon
    const wX = x + Math.round((w - tile)/2);
    const wY = y + mTop;
    const weapon = { x: wX, y: wY, w: tile, h: tile };
    // Items grid (12x1), square tiles snapped
    const itemsH = tile * 12;
    const itemsY = Math.min(y + h - mBot - itemsH, wY + tile + Math.round(h*0.08));
    const itemsX = x + Math.round((w - tile)/2);
    const items = { x: itemsX, y: itemsY, w: tile, h: itemsH, rows:12, cols:1 };
    // Oils row below weapon
    const oilsH = Math.round(tile * 3);
    const oilsY = Math.min(itemsY - Math.round(h*0.02) - oilsH, y + wY + tile + Math.round(h*0.02));
    const oils = { x: itemsX, y: oilsY, w: tile, h: oilsH, rows:3, cols:1 };
    // Edge box to the right of oils (optional)
    const edge = { x: itemsX + tile + Math.round(w*0.04), y: oilsY, w: tile, h: tile };
    const L = (k,obj)=>{ ROIS[(sideKey==='P'?'left':'right')+'-'+k] = obj; };
    L('weapon', weapon); L('items', items); L('oils', oils); L('edge', edge);
    render();
    // Switch target to items for quick tweaks
    roiTarget.value = (sideKey==='P') ? 'left-items' : 'right-items';
    // run preview
    scanAndApply();
  }
  if (btnPresetLeft) btnPresetLeft.addEventListener('click', ()=>{ presetSide='P'; if(presetHint) presetHint.textContent='Draw a rectangle around the LEFT panel'; });
  if (btnPresetRight) btnPresetRight.addEventListener('click', ()=>{ presetSide='O'; if(presetHint) presetHint.textContent='Draw a rectangle around the RIGHT panel'; });
  if (btnQuickLeft) btnQuickLeft.addEventListener('click', ()=>{ QUICK.active=true; QUICK.side='P'; if (quickHint) quickHint.textContent='LEFT: Draw the WEAPON tile only'; });
  if (btnQuickRight) btnQuickRight.addEventListener('click', ()=>{ QUICK.active=true; QUICK.side='O'; if (quickHint) quickHint.textContent='RIGHT: Draw the WEAPON tile only'; });
  const wizardHint = document.getElementById('wizardHint');
  const btnWizardLeft = document.getElementById('btnWizardLeft');
  const btnWizardRight = document.getElementById('btnWizardRight');
  const btnWizardNext = document.getElementById('btnWizardNext');
  const btnWizardCancel = document.getElementById('btnWizardCancel');
  const WIZ = { active:false, side:null, step:0, rects:{} };
  function wizSetHint(){
    const s = WIZ.side==='P'?'LEFT':'RIGHT';
    const map = { 1:`${s}: Draw panel bounds`, 2:`${s}: Draw WEAPON tile`, 3:`${s}: Draw ITEM tile row #1`, 4:`${s}: Draw ITEM tile row #2 (one below)`, 5:`${s}: Draw OILS tile (optional) or press Next`, 6:`${s}: Draw EDGE box (optional) or press Next` };
    if (wizardHint) wizardHint.textContent = map[WIZ.step] || '';
  }
  function startWizard(side){ WIZ.active=true; WIZ.side=side; WIZ.step=1; WIZ.rects={}; wizSetHint(); }
  if (btnWizardLeft) btnWizardLeft.addEventListener('click', ()=> startWizard('P'));
  if (btnWizardRight) btnWizardRight.addEventListener('click', ()=> startWizard('O'));
  if (btnWizardCancel) btnWizardCancel.addEventListener('click', ()=> { WIZ.active=false; WIZ.side=null; WIZ.step=0; WIZ.rects={}; if(wizardHint) wizardHint.textContent=''; });
  if (btnWizardNext) btnWizardNext.addEventListener('click', ()=> { if (!WIZ.active) return; onWizardRect(null); });
  function onWizardRect(rect){ if (!WIZ.active) return; const sKey=(WIZ.side==='P')?'left':'right'; const norm=(r)=>{ if(!r) return null; let {x,y,w,h}=r; if(w<0){x+=w;w=-w;} if(h<0){y+=h;h=-h;} return {x,y,w,h}; };
    if (WIZ.step===1){ WIZ.rects.panel=norm(rect); WIZ.step=2; wizSetHint(); return; }
    if (WIZ.step===2){ WIZ.rects.weapon=norm(rect); WIZ.step=3; wizSetHint(); return; }
    if (WIZ.step===3){ WIZ.rects.item1=norm(rect); WIZ.step=4; wizSetHint(); return; }
    if (WIZ.step===4){ WIZ.rects.item2=norm(rect); WIZ.step=5; wizSetHint(); return; }
    if (WIZ.step===5){ WIZ.rects.oils=norm(rect); WIZ.step=6; wizSetHint(); return; }
    if (WIZ.step===6){ WIZ.rects.edge=norm(rect); WIZ.step=7; }
    const it1=WIZ.rects.item1, it2=WIZ.rects.item2; const weapon=WIZ.rects.weapon; if (it1 && it2){ const step=Math.max(8, Math.round(it2.y - it1.y)); const tileW=it1.w; ROIS[`${sKey}-items`] = { x:it1.x, y:it1.y, w:tileW, h:step*12, rows:12, cols:1 }; }
    if (weapon) ROIS[`${sKey}-weapon`]=weapon; if (WIZ.rects.oils) ROIS[`${sKey}-oils`]=Object.assign({},WIZ.rects.oils,{rows:3,cols:1}); if (WIZ.rects.edge) ROIS[`${sKey}-edge`]=WIZ.rects.edge; WIZ.active=false; WIZ.step=0; wizSetHint(); render(); scanAndApply(); }

  // Quick mode: build a 12×1 grid from a single weapon-tile rectangle
  function onQuickWeaponRect(rect){
    if (!QUICK.active || !rect) { QUICK.active=false; if (quickHint) quickHint.textContent=''; return; }
    let {x,y,w,h}=rect; if (w<0){x+=w;w=-w;} if (h<0){y+=h;h=-h;}
    const s = Math.min(w,h); // enforce square
    const sideKey = (QUICK.side==='P') ? 'left' : 'right';
    ROIS[`${sideKey}-weapon`] = { x:x, y:y, w:s, h:s };
    // scan for first item frame directly below weapon using edge brightness on full-res image
    const scoreAt = (ty)=>{ let sum=0, cnt=0; try{ const r=viewToSrcRect(x, ty, s, s); const sw=r.sw, sh=r.sh; const img=srcCtx.getImageData(r.sx, r.sy, sw, sh).data; const idx=(px,py)=>{ const i=(py*sw+px)*4; return img[i]+img[i+1]+img[i+2]; }; for(let px=2; px<sw-2; px+=Math.max(2, Math.floor(sw/24))){ sum+=idx(px,2)+idx(px,3)+idx(px,sh-3)+idx(px,sh-2); cnt+=4; } for(let py=2; py<sh-2; py+=Math.max(2, Math.floor(sh/24))){ sum+=idx(2,py)+idx(3,py)+idx(sw-3,py)+idx(sw-2,py); cnt+=4; } }catch(_){ } return cnt?sum/cnt:0; };
    const start = y + s + Math.floor(s*0.05), end = start + Math.floor(s*2.2); let bestY=start, best= -1; for(let ty=start; ty<=end; ty+=2){ const sc=scoreAt(ty); if(sc>best){ best=sc; bestY=ty; } }
    const gap = Math.max(4, bestY - (y+s)); const step = s + gap;
    // derive rows (max 12) until canvas bottom
    let rows=0; while (rows<12 && (bestY + rows*step + s) <= canvas.height) rows++;
    if (rows < 1) rows = 10; // fallback
    ROIS[`${sideKey}-items`] = { x:x, y:bestY, w:s, h:step*rows, rows:rows, cols:1 };
    QUICK.active=false; if (quickHint) quickHint.textContent=''; render(); scanAndApply();
  }

  // Presets for rows/cols by target type
  roiTarget.addEventListener('change', () => {
    const t = roiTarget.value;
    if (/items/.test(t)) { roiRows.value = '12'; roiCols.value = '1'; }
    else if (/oils/.test(t)) { roiRows.value = '3'; roiCols.value = '1'; }
    else { roiRows.value = '1'; roiCols.value = '1'; }
    render();
  });
})();
*/


// Tab switching logic
const compendiumTab = document.getElementById('compendiumTab');
const simulationTab = document.getElementById('simulationTab');
// importTab removed; set to null
const importTab = null;
const tabCompendium = document.getElementById('tabCompendium');
const tabSimulation = document.getElementById('tabSimulation');
if (tabCompendium && tabSimulation && compendiumTab && simulationTab) {
  tabCompendium.addEventListener('click', () => {
    compendiumTab.style.display = '';
    simulationTab.style.display = 'none';
    // importTab removed
    tabCompendium.style.background = '#111';
    tabCompendium.style.color = '#f33';
    tabSimulation.style.background = '#111';
    tabSimulation.style.color = '#0f3';
    // tabImport removed
  });
  tabSimulation.addEventListener('click', () => {
    compendiumTab.style.display = 'none';
    simulationTab.style.display = '';
    // importTab removed
    tabCompendium.style.background = '#111';
    tabCompendium.style.color = '#f33';
    tabSimulation.style.background = '#111';
    tabSimulation.style.color = '#0f3';
    // tabImport removed
  });
}
if (showSimBtn && simulationTab && compendiumTab) {
  showSimBtn.addEventListener('click', () => {
    compendiumTab.style.display = 'none';
    simulationTab.style.display = '';
    tabCompendium.style.background = '#111';
    tabCompendium.style.color = '#f33';
    tabSimulation.style.background = '#111';
    tabSimulation.style.color = '#0f3';
  });
}

// Initial render happens after details.json loads via loadData()
</script>

</body>
</html>

